SimpleLcg | Medium | Crypto | 100

# SimpleLcg | Medium | Crypto | 100

## Информация

Я написал свой простенький генератор псевдоcлучайных чисел. Можешь проверить его на наличие уязвимостей?

## Описание

Нужно восстановить seed LCG (Linear Congruential Generator)

## Решение

Оптимизируем и инвертируем алгоритм, пишем скрипт для решения:

```python
from Crypto.Util.number import long_to_bytes

a = 0x4242
p, b = (
    117782817498564430315387215565566287917140110251395009114730589622991376348728841892717560653816140026579816065470345482205507853148696419319258669613414355394128143913006602171177352618249597926563500280129653872770002125453521299128567014511191785547348892237340927181460436616702980334209821747513725287957,
    128929919131842167853071985306201591700869345406876846038519478669119340311339453071864136686092478024230574878046605016808452003953480451683505688762770282264035843661479178548771303627411345523493955284130089521592625067988477328009790828679527930734242826911803484091106070352622748344577476793196567280269
)
state = 83910084068707809819425068114399616340526647716672466641668217764181264761589277524413593199601885845312909089460836584229511223151581749176956371407132716531510846769662275255325529724311936059152758452106290801063636143410789437979543543582015498321409792281360658202404199433557365425063245291938587959821

# Вычисление обратных элементов
apow = pow(a, 2 ** 0x100, p)
inv_apow = pow(apow, p - 2, p)  # Обратный элемент для apow
inv_amin = pow(a - 1, p - 2, p) # Обратный элемент для (a-1)

# Вычисление суммы геометрической прогрессии
sum_part = (apow - 1) * inv_amin % p
term = (b * sum_part) % p

# Восстановление начального значения
seed = (state - term) * inv_apow % p

print(long_to_bytes(seed))
```



Флаг
letoctf{s33d_r3c0v3r_lc6_15_n07_53cur3}
